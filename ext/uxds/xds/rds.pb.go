// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        (unknown)
// source: xds/rds.proto

package xds

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type VirtualHost_TlsRequirementType int32

const (
	// No TLS requirement for the virtual host.
	VirtualHost_NONE VirtualHost_TlsRequirementType = 0
	// External requests must use TLS. If a request is external and it is not
	// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
	VirtualHost_EXTERNAL_ONLY VirtualHost_TlsRequirementType = 1
	// All requests must use TLS. If a request is not using TLS, a 301 redirect
	// will be sent telling the client to use HTTPS.
	VirtualHost_ALL VirtualHost_TlsRequirementType = 2
)

// Enum value maps for VirtualHost_TlsRequirementType.
var (
	VirtualHost_TlsRequirementType_name = map[int32]string{
		0: "NONE",
		1: "EXTERNAL_ONLY",
		2: "ALL",
	}
	VirtualHost_TlsRequirementType_value = map[string]int32{
		"NONE":          0,
		"EXTERNAL_ONLY": 1,
		"ALL":           2,
	}
)

func (x VirtualHost_TlsRequirementType) Enum() *VirtualHost_TlsRequirementType {
	p := new(VirtualHost_TlsRequirementType)
	*p = x
	return p
}

func (x VirtualHost_TlsRequirementType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VirtualHost_TlsRequirementType) Descriptor() protoreflect.EnumDescriptor {
	return file_xds_rds_proto_enumTypes[0].Descriptor()
}

func (VirtualHost_TlsRequirementType) Type() protoreflect.EnumType {
	return &file_xds_rds_proto_enumTypes[0]
}

func (x VirtualHost_TlsRequirementType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VirtualHost_TlsRequirementType.Descriptor instead.
func (VirtualHost_TlsRequirementType) EnumDescriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{1, 0}
}

type RouteAction_ClusterNotFoundResponseCode int32

const (
	// HTTP status code - 503 Service Unavailable.
	RouteAction_SERVICE_UNAVAILABLE RouteAction_ClusterNotFoundResponseCode = 0
	// HTTP status code - 404 Not Found.
	RouteAction_NOT_FOUND RouteAction_ClusterNotFoundResponseCode = 1
)

// Enum value maps for RouteAction_ClusterNotFoundResponseCode.
var (
	RouteAction_ClusterNotFoundResponseCode_name = map[int32]string{
		0: "SERVICE_UNAVAILABLE",
		1: "NOT_FOUND",
	}
	RouteAction_ClusterNotFoundResponseCode_value = map[string]int32{
		"SERVICE_UNAVAILABLE": 0,
		"NOT_FOUND":           1,
	}
)

func (x RouteAction_ClusterNotFoundResponseCode) Enum() *RouteAction_ClusterNotFoundResponseCode {
	p := new(RouteAction_ClusterNotFoundResponseCode)
	*p = x
	return p
}

func (x RouteAction_ClusterNotFoundResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteAction_ClusterNotFoundResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_xds_rds_proto_enumTypes[1].Descriptor()
}

func (RouteAction_ClusterNotFoundResponseCode) Type() protoreflect.EnumType {
	return &file_xds_rds_proto_enumTypes[1]
}

func (x RouteAction_ClusterNotFoundResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteAction_ClusterNotFoundResponseCode.Descriptor instead.
func (RouteAction_ClusterNotFoundResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 0}
}

// Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
// [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
type RouteAction_InternalRedirectAction int32

const (
	RouteAction_PASS_THROUGH_INTERNAL_REDIRECT RouteAction_InternalRedirectAction = 0
	RouteAction_HANDLE_INTERNAL_REDIRECT       RouteAction_InternalRedirectAction = 1
)

// Enum value maps for RouteAction_InternalRedirectAction.
var (
	RouteAction_InternalRedirectAction_name = map[int32]string{
		0: "PASS_THROUGH_INTERNAL_REDIRECT",
		1: "HANDLE_INTERNAL_REDIRECT",
	}
	RouteAction_InternalRedirectAction_value = map[string]int32{
		"PASS_THROUGH_INTERNAL_REDIRECT": 0,
		"HANDLE_INTERNAL_REDIRECT":       1,
	}
)

func (x RouteAction_InternalRedirectAction) Enum() *RouteAction_InternalRedirectAction {
	p := new(RouteAction_InternalRedirectAction)
	*p = x
	return p
}

func (x RouteAction_InternalRedirectAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteAction_InternalRedirectAction) Descriptor() protoreflect.EnumDescriptor {
	return file_xds_rds_proto_enumTypes[2].Descriptor()
}

func (RouteAction_InternalRedirectAction) Type() protoreflect.EnumType {
	return &file_xds_rds_proto_enumTypes[2]
}

func (x RouteAction_InternalRedirectAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteAction_InternalRedirectAction.Descriptor instead.
func (RouteAction_InternalRedirectAction) EnumDescriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1}
}

type RouteConfiguration struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the route configuration. For example, it might match
	// :ref:`route_config_name
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.Rds.route_config_name>` in
	// :ref:`envoy_api_msg_extensions.filters.network.http_connection_manager.v3.Rds`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An array of virtual hosts that make up the route table.
	VirtualHosts []*VirtualHost `protobuf:"bytes,2,rep,name=virtual_hosts,json=virtualHosts,proto3" json:"virtual_hosts,omitempty"`
	// Optionally specifies a list of HTTP headers that the connection manager
	// will consider to be internal only. If they are found on external requests they will be cleaned
	// prior to filter invocation. See :ref:`config_http_conn_man_headers_x-envoy-internal` for more
	// information.
	InternalOnlyHeaders []string `protobuf:"bytes,3,rep,name=internal_only_headers,json=internalOnlyHeaders,proto3" json:"internal_only_headers,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// that the connection manager encodes.
	ResponseHeadersToRemove []string `protobuf:"bytes,5,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each request
	// routed by the HTTP connection manager.
	RequestHeadersToRemove []string `protobuf:"bytes,8,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// By default, headers that should be added/removed are evaluated from most to least specific:
	//
	// * route level
	// * virtual host level
	// * connection manager level
	//
	// To allow setting overrides at the route or virtual host level, this order can be reversed
	// by setting this option to true. Defaults to false.
	//
	// [#next-major-version: In the v3 API, this will default to true.]
	MostSpecificHeaderMutationsWins bool `protobuf:"varint,10,opt,name=most_specific_header_mutations_wins,json=mostSpecificHeaderMutationsWins,proto3" json:"most_specific_header_mutations_wins,omitempty"`
	// The maximum bytes of the response :ref:`direct response body
	// <envoy_api_field_config.route.v3.DirectResponseAction.body>` size. If not specified the default
	// is 4096.
	//
	// .. warning::
	//
	//   Envoy currently holds the content of :ref:`direct response body
	//   <envoy_api_field_config.route.v3.DirectResponseAction.body>` in memory. Be careful setting
	//   this to be larger than the default 4KB, since the allocated memory for direct response body
	//   is not subject to data plane buffering controls.
	//
	MaxDirectResponseBodySizeBytes *UInt32Value `protobuf:"bytes,11,opt,name=max_direct_response_body_size_bytes,json=maxDirectResponseBodySizeBytes,proto3" json:"max_direct_response_body_size_bytes,omitempty"`
}

func (x *RouteConfiguration) Reset() {
	*x = RouteConfiguration{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteConfiguration) ProtoMessage() {}

func (x *RouteConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteConfiguration.ProtoReflect.Descriptor instead.
func (*RouteConfiguration) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{0}
}

func (x *RouteConfiguration) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RouteConfiguration) GetVirtualHosts() []*VirtualHost {
	if x != nil {
		return x.VirtualHosts
	}
	return nil
}

func (x *RouteConfiguration) GetInternalOnlyHeaders() []string {
	if x != nil {
		return x.InternalOnlyHeaders
	}
	return nil
}

func (x *RouteConfiguration) GetResponseHeadersToRemove() []string {
	if x != nil {
		return x.ResponseHeadersToRemove
	}
	return nil
}

func (x *RouteConfiguration) GetRequestHeadersToRemove() []string {
	if x != nil {
		return x.RequestHeadersToRemove
	}
	return nil
}

func (x *RouteConfiguration) GetMostSpecificHeaderMutationsWins() bool {
	if x != nil {
		return x.MostSpecificHeaderMutationsWins
	}
	return false
}

func (x *RouteConfiguration) GetMaxDirectResponseBodySizeBytes() *UInt32Value {
	if x != nil {
		return x.MaxDirectResponseBodySizeBytes
	}
	return nil
}

// The top level element in the routing configuration is a virtual host. Each virtual host has
// a logical name as well as a set of domains that get routed to it based on the incoming request's
// host header. This allows a single listener to service multiple top level domain path trees. Once
// a virtual host is selected based on the domain, the routes are processed in order to see which
// upstream cluster to route to or whether to perform a redirect.
// [#next-free-field: 21]
type VirtualHost struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The logical name of the virtual host. This is used when emitting certain
	// statistics but is not relevant for routing.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// A list of domains (host/authority header) that will be matched to this
	// virtual host. Wildcard hosts are supported in the suffix or prefix form.
	//
	// Domain search order:
	//  1. Exact domain names: ``www.foo.com``.
	//  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
	//  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
	//  4. Special wildcard ``*`` matching any domain.
	//
	// .. note::
	//
	//   The wildcard will not match the empty string.
	//   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
	//   The longest wildcards match first.
	//   Only a single virtual host in the entire route configuration can match on ``*``. A domain
	//   must be unique across all virtual hosts or the config will fail to load.
	//
	// Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
	Domains []string `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	// The list of routes that will be matched, in order, for incoming requests.
	// The first route that matches will be used.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// Specifies the type of TLS enforcement the virtual host expects. If this option is not
	// specified, there is no TLS requirement for the virtual host.
	RequireTls VirtualHost_TlsRequirementType `protobuf:"varint,4,opt,name=require_tls,json=requireTls,proto3,enum=xds.VirtualHost_TlsRequirementType" json:"require_tls,omitempty"`
	// Decides whether the :ref:`x-envoy-attempt-count
	// <config_http_filters_router_x-envoy-attempt-count>` header should be included
	// in the upstream request. Setting this option will cause it to override any existing header
	// value, so in the case of two Envoys on the request path with this option enabled, the upstream
	// will see the attempt count as perceived by the second Envoy. Defaults to false.
	// This header is unaffected by the
	// :ref:`suppress_envoy_headers
	// <envoy_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
	//
	// [#next-major-version: rename to include_attempt_count_in_request.]
	IncludeRequestAttemptCount bool `protobuf:"varint,14,opt,name=include_request_attempt_count,json=includeRequestAttemptCount,proto3" json:"include_request_attempt_count,omitempty"`
	// Decides whether the :ref:`x-envoy-attempt-count
	// <config_http_filters_router_x-envoy-attempt-count>` header should be included
	// in the downstream response. Setting this option will cause the router to override any existing header
	// value, so in the case of two Envoys on the request path with this option enabled, the downstream
	// will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
	// This header is unaffected by the
	// :ref:`suppress_envoy_headers
	// <envoy_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
	IncludeAttemptCountInResponse bool `protobuf:"varint,19,opt,name=include_attempt_count_in_response,json=includeAttemptCountInResponse,proto3" json:"include_attempt_count_in_response,omitempty"`
	// The maximum bytes which will be buffered for retries and shadowing.
	// If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
	// value of this and the listener per_connection_buffer_limit_bytes.
	PerRequestBufferLimitBytes *UInt32Value `protobuf:"bytes,18,opt,name=per_request_buffer_limit_bytes,json=perRequestBufferLimitBytes,proto3" json:"per_request_buffer_limit_bytes,omitempty"`
}

func (x *VirtualHost) Reset() {
	*x = VirtualHost{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VirtualHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VirtualHost) ProtoMessage() {}

func (x *VirtualHost) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VirtualHost.ProtoReflect.Descriptor instead.
func (*VirtualHost) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{1}
}

func (x *VirtualHost) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VirtualHost) GetDomains() []string {
	if x != nil {
		return x.Domains
	}
	return nil
}

func (x *VirtualHost) GetRoutes() []*Route {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *VirtualHost) GetRequireTls() VirtualHost_TlsRequirementType {
	if x != nil {
		return x.RequireTls
	}
	return VirtualHost_NONE
}

func (x *VirtualHost) GetIncludeRequestAttemptCount() bool {
	if x != nil {
		return x.IncludeRequestAttemptCount
	}
	return false
}

func (x *VirtualHost) GetIncludeAttemptCountInResponse() bool {
	if x != nil {
		return x.IncludeAttemptCountInResponse
	}
	return false
}

func (x *VirtualHost) GetPerRequestBufferLimitBytes() *UInt32Value {
	if x != nil {
		return x.PerRequestBufferLimitBytes
	}
	return nil
}

// A route is both a specification of how to match a request as well as an indication of what to do
// next (e.g., redirect, forward, rewrite, etc.).
//
// .. attention::
//
//   Envoy supports routing on HTTP method via :ref:`header matching
//   <envoy_api_msg_config.route.v3.HeaderMatcher>`.
// [#next-free-field: 18]
type Route struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name for the route.
	Name string `protobuf:"bytes,14,opt,name=name,proto3" json:"name,omitempty"`
	// Route matching parameters.
	Match *RouteMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Types that are assignable to Action:
	//	*Route_Route
	Action isRoute_Action `protobuf_oneof:"action"`
	// The Metadata field can be used to provide additional information
	// about the route. It can be used for configuration, stats, and logging.
	// The metadata should go under the filter namespace that will need it.
	// For instance, if the metadata is intended for the Router filter,
	// the filter name should be specified as *envoy.filters.http.router*.
	Metadata *Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The typed_per_filter_config field can be used to provide route-specific
	// configurations for filters. The key should match the filter name, such as
	// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
	// specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
	// if and how it is utilized.
	// [#comment: An entry's value may be wrapped in a
	// :ref:`FilterConfig<envoy_api_msg_config.route.v3.FilterConfig>`
	// message to specify additional options.]
	TypedPerFilterConfig map[string]*Any `protobuf:"bytes,13,rep,name=typed_per_filter_config,json=typedPerFilterConfig,proto3" json:"typed_per_filter_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Specifies a list of HTTP headers that should be removed from each request
	// matching this route.
	RequestHeadersToRemove []string `protobuf:"bytes,12,rep,name=request_headers_to_remove,json=requestHeadersToRemove,proto3" json:"request_headers_to_remove,omitempty"`
	// Specifies a list of HTTP headers that should be removed from each response
	// to requests matching this route.
	ResponseHeadersToRemove []string `protobuf:"bytes,11,rep,name=response_headers_to_remove,json=responseHeadersToRemove,proto3" json:"response_headers_to_remove,omitempty"`
	// The maximum bytes which will be buffered for retries and shadowing.
	// If set, the bytes actually buffered will be the minimum value of this and the
	// listener per_connection_buffer_limit_bytes.
	PerRequestBufferLimitBytes *UInt32Value `protobuf:"bytes,16,opt,name=per_request_buffer_limit_bytes,json=perRequestBufferLimitBytes,proto3" json:"per_request_buffer_limit_bytes,omitempty"`
}

func (x *Route) Reset() {
	*x = Route{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Route) ProtoMessage() {}

func (x *Route) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Route.ProtoReflect.Descriptor instead.
func (*Route) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{2}
}

func (x *Route) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Route) GetMatch() *RouteMatch {
	if x != nil {
		return x.Match
	}
	return nil
}

func (m *Route) GetAction() isRoute_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (x *Route) GetRoute() *RouteAction {
	if x, ok := x.GetAction().(*Route_Route); ok {
		return x.Route
	}
	return nil
}

func (x *Route) GetMetadata() *Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Route) GetTypedPerFilterConfig() map[string]*Any {
	if x != nil {
		return x.TypedPerFilterConfig
	}
	return nil
}

func (x *Route) GetRequestHeadersToRemove() []string {
	if x != nil {
		return x.RequestHeadersToRemove
	}
	return nil
}

func (x *Route) GetResponseHeadersToRemove() []string {
	if x != nil {
		return x.ResponseHeadersToRemove
	}
	return nil
}

func (x *Route) GetPerRequestBufferLimitBytes() *UInt32Value {
	if x != nil {
		return x.PerRequestBufferLimitBytes
	}
	return nil
}

type isRoute_Action interface {
	isRoute_Action()
}

type Route_Route struct {
	// Route request to some upstream cluster.
	Route *RouteAction `protobuf:"bytes,2,opt,name=route,proto3,oneof"`
}

func (*Route_Route) isRoute_Action() {}

// [#next-free-field: 13]
type RouteMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to PathSpecifier:
	//	*RouteMatch_Prefix
	//	*RouteMatch_Path
	//	*RouteMatch_ConnectMatcher_
	PathSpecifier isRouteMatch_PathSpecifier `protobuf_oneof:"path_specifier"`
	// Indicates that prefix/path matching should be case sensitive. The default
	// is true.
	CaseSensitive *BoolValue `protobuf:"bytes,4,opt,name=case_sensitive,json=caseSensitive,proto3" json:"case_sensitive,omitempty"`
	// If specified, only gRPC requests will be matched. The router will check
	// that the content-type header has a application/grpc or one of the various
	// application/grpc+ values.
	Grpc *RouteMatch_GrpcRouteMatchOptions `protobuf:"bytes,8,opt,name=grpc,proto3" json:"grpc,omitempty"`
	// If specified, the client tls context will be matched against the defined
	// match options.
	//
	// [#next-major-version: unify with RBAC]
	TlsContext *RouteMatch_TlsContextMatchOptions `protobuf:"bytes,11,opt,name=tls_context,json=tlsContext,proto3" json:"tls_context,omitempty"`
}

func (x *RouteMatch) Reset() {
	*x = RouteMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteMatch) ProtoMessage() {}

func (x *RouteMatch) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteMatch.ProtoReflect.Descriptor instead.
func (*RouteMatch) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{3}
}

func (m *RouteMatch) GetPathSpecifier() isRouteMatch_PathSpecifier {
	if m != nil {
		return m.PathSpecifier
	}
	return nil
}

func (x *RouteMatch) GetPrefix() string {
	if x, ok := x.GetPathSpecifier().(*RouteMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (x *RouteMatch) GetPath() string {
	if x, ok := x.GetPathSpecifier().(*RouteMatch_Path); ok {
		return x.Path
	}
	return ""
}

func (x *RouteMatch) GetConnectMatcher() *RouteMatch_ConnectMatcher {
	if x, ok := x.GetPathSpecifier().(*RouteMatch_ConnectMatcher_); ok {
		return x.ConnectMatcher
	}
	return nil
}

func (x *RouteMatch) GetCaseSensitive() *BoolValue {
	if x != nil {
		return x.CaseSensitive
	}
	return nil
}

func (x *RouteMatch) GetGrpc() *RouteMatch_GrpcRouteMatchOptions {
	if x != nil {
		return x.Grpc
	}
	return nil
}

func (x *RouteMatch) GetTlsContext() *RouteMatch_TlsContextMatchOptions {
	if x != nil {
		return x.TlsContext
	}
	return nil
}

type isRouteMatch_PathSpecifier interface {
	isRouteMatch_PathSpecifier()
}

type RouteMatch_Prefix struct {
	// If specified, the route is a prefix rule meaning that the prefix must
	// match the beginning of the *:path* header.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof"`
}

type RouteMatch_Path struct {
	// If specified, the route is an exact path rule meaning that the path must
	// exactly match the *:path* header once the query string is removed.
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof"`
}

type RouteMatch_ConnectMatcher_ struct {
	// If this is used as the matcher, the matcher will only match CONNECT requests.
	// Note that this will not match HTTP/2 upgrade-style CONNECT requests
	// (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
	// upgrades.
	// This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
	// where Extended CONNECT requests may have a path, the path matchers will work if
	// there is a path present.
	// Note that CONNECT support is currently considered alpha in Envoy.
	// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
	ConnectMatcher *RouteMatch_ConnectMatcher `protobuf:"bytes,12,opt,name=connect_matcher,json=connectMatcher,proto3,oneof"`
}

func (*RouteMatch_Prefix) isRouteMatch_PathSpecifier() {}

func (*RouteMatch_Path) isRouteMatch_PathSpecifier() {}

func (*RouteMatch_ConnectMatcher_) isRouteMatch_PathSpecifier() {}

// [#next-free-field: 37]
type RouteAction struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to ClusterSpecifier:
	//	*RouteAction_Cluster
	//	*RouteAction_ClusterHeader
	ClusterSpecifier isRouteAction_ClusterSpecifier `protobuf_oneof:"cluster_specifier"`
	// The HTTP status code to use when configured cluster is not found.
	// The default response code is 503 Service Unavailable.
	ClusterNotFoundResponseCode RouteAction_ClusterNotFoundResponseCode `protobuf:"varint,20,opt,name=cluster_not_found_response_code,json=clusterNotFoundResponseCode,proto3,enum=xds.RouteAction_ClusterNotFoundResponseCode" json:"cluster_not_found_response_code,omitempty"`
	// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
	// in the upstream cluster with metadata matching what's set in this field will be considered
	// for load balancing. If using :ref:`weighted_clusters
	// <envoy_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
	// provided there taking precedence. The filter name should be specified as *envoy.lb*.
	MetadataMatch *Metadata `protobuf:"bytes,4,opt,name=metadata_match,json=metadataMatch,proto3" json:"metadata_match,omitempty"`
	// Indicates that during forwarding, the matched prefix (or path) should be
	// swapped with this value. This option allows application URLs to be rooted
	// at a different path from those exposed at the reverse proxy layer. The router filter will
	// place the original path before rewrite into the :ref:`x-envoy-original-path
	// <config_http_filters_router_x-envoy-original-path>` header.
	//
	// Only one of *prefix_rewrite* or
	// :ref:`regex_rewrite <envoy_api_field_config.route.v3.RouteAction.regex_rewrite>`
	// may be specified.
	//
	// .. attention::
	//
	//   Pay careful attention to the use of trailing slashes in the
	//   :ref:`route's match <envoy_api_field_config.route.v3.Route.match>` prefix value.
	//   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
	//   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
	//   :ref:`Route <envoy_api_msg_config.route.v3.Route>`, as shown by the below config entries:
	//
	//   .. code-block:: yaml
	//
	//     - match:
	//         prefix: "/prefix/"
	//       route:
	//         prefix_rewrite: "/"
	//     - match:
	//         prefix: "/prefix"
	//       route:
	//         prefix_rewrite: "/"
	//
	//   Having above entries in the config, requests to */prefix* will be stripped to */*, while
	//   requests to */prefix/etc* will be stripped to */etc*.
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3" json:"prefix_rewrite,omitempty"`
	// Types that are assignable to HostRewriteSpecifier:
	//	*RouteAction_HostRewriteLiteral
	//	*RouteAction_AutoHostRewrite
	//	*RouteAction_HostRewriteHeader
	HostRewriteSpecifier isRouteAction_HostRewriteSpecifier `protobuf_oneof:"host_rewrite_specifier"`
	// Specifies the upstream timeout for the route. If not specified, the default is 15s. This
	// spans between the point at which the entire downstream request (i.e. end-of-stream) has been
	// processed and when the upstream response has been completely processed. A value of 0 will
	// disable the route's timeout.
	//
	// .. note::
	//
	//   This timeout includes all retries. See also
	//   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
	//   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
	//   :ref:`retry overview <arch_overview_http_routing_retry>`.
	Timeout *Duration `protobuf:"bytes,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
	// although the connection manager wide :ref:`stream_idle_timeout
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
	// will still apply. A value of 0 will completely disable the route's idle timeout, even if a
	// connection manager stream idle timeout is configured.
	//
	// The idle timeout is distinct to :ref:`timeout
	// <envoy_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
	// on the upstream response time; :ref:`idle_timeout
	// <envoy_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
	// of time the request's stream may be idle.
	//
	// After header decoding, the idle timeout will apply on downstream and
	// upstream request events. Each time an encode/decode event for headers or
	// data is processed for the stream, the timer will be reset. If the timeout
	// fires, the stream is terminated with a 408 Request Timeout error code if no
	// upstream response header has been received, otherwise a stream reset
	// occurs.
	//
	// If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
	// is configured, this timeout is scaled according to the value for
	// :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
	IdleTimeout *Duration `protobuf:"bytes,24,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// [#not-implemented-hide:]
	// Specifies the configuration for retry policy extension. Note that if this is set, it'll take
	// precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
	// most internal one becomes the enforced policy). :ref:`Retry policy <envoy_api_field_config.route.v3.VirtualHost.retry_policy>`
	// should not be set if this field is used.
	RetryPolicyTypedConfig *Any `protobuf:"bytes,33,opt,name=retry_policy_typed_config,json=retryPolicyTypedConfig,proto3" json:"retry_policy_typed_config,omitempty"`
	// Indicates that the route has request mirroring policies.
	RequestMirrorPolicies []*RouteAction_RequestMirrorPolicy `protobuf:"bytes,30,rep,name=request_mirror_policies,json=requestMirrorPolicies,proto3" json:"request_mirror_policies,omitempty"`
	// Specifies a list of hash policies to use for ring hash load balancing. Each
	// hash policy is evaluated individually and the combined result is used to
	// route the request. The method of combination is deterministic such that
	// identical lists of hash policies will produce the same hash. Since a hash
	// policy examines specific parts of a request, it can fail to produce a hash
	// (i.e. if the hashed header is not present). If (and only if) all configured
	// hash policies fail to generate a hash, no hash will be produced for
	// the route. In this case, the behavior is the same as if no hash policies
	// were specified (i.e. the ring hash load balancer will choose a random
	// backend). If a hash policy has the "terminal" attribute set to true, and
	// there is already a hash generated, the hash is returned immediately,
	// ignoring the rest of the hash policy list.
	HashPolicy     []*RouteAction_HashPolicy    `protobuf:"bytes,15,rep,name=hash_policy,json=hashPolicy,proto3" json:"hash_policy,omitempty"`
	UpgradeConfigs []*RouteAction_UpgradeConfig `protobuf:"bytes,25,rep,name=upgrade_configs,json=upgradeConfigs,proto3" json:"upgrade_configs,omitempty"`
	// Specifies the maximum stream duration for this route.
	MaxStreamDuration *RouteAction_MaxStreamDuration `protobuf:"bytes,36,opt,name=max_stream_duration,json=maxStreamDuration,proto3" json:"max_stream_duration,omitempty"`
}

func (x *RouteAction) Reset() {
	*x = RouteAction{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction) ProtoMessage() {}

func (x *RouteAction) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction.ProtoReflect.Descriptor instead.
func (*RouteAction) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4}
}

func (m *RouteAction) GetClusterSpecifier() isRouteAction_ClusterSpecifier {
	if m != nil {
		return m.ClusterSpecifier
	}
	return nil
}

func (x *RouteAction) GetCluster() string {
	if x, ok := x.GetClusterSpecifier().(*RouteAction_Cluster); ok {
		return x.Cluster
	}
	return ""
}

func (x *RouteAction) GetClusterHeader() string {
	if x, ok := x.GetClusterSpecifier().(*RouteAction_ClusterHeader); ok {
		return x.ClusterHeader
	}
	return ""
}

func (x *RouteAction) GetClusterNotFoundResponseCode() RouteAction_ClusterNotFoundResponseCode {
	if x != nil {
		return x.ClusterNotFoundResponseCode
	}
	return RouteAction_SERVICE_UNAVAILABLE
}

func (x *RouteAction) GetMetadataMatch() *Metadata {
	if x != nil {
		return x.MetadataMatch
	}
	return nil
}

func (x *RouteAction) GetPrefixRewrite() string {
	if x != nil {
		return x.PrefixRewrite
	}
	return ""
}

func (m *RouteAction) GetHostRewriteSpecifier() isRouteAction_HostRewriteSpecifier {
	if m != nil {
		return m.HostRewriteSpecifier
	}
	return nil
}

func (x *RouteAction) GetHostRewriteLiteral() string {
	if x, ok := x.GetHostRewriteSpecifier().(*RouteAction_HostRewriteLiteral); ok {
		return x.HostRewriteLiteral
	}
	return ""
}

func (x *RouteAction) GetAutoHostRewrite() *BoolValue {
	if x, ok := x.GetHostRewriteSpecifier().(*RouteAction_AutoHostRewrite); ok {
		return x.AutoHostRewrite
	}
	return nil
}

func (x *RouteAction) GetHostRewriteHeader() string {
	if x, ok := x.GetHostRewriteSpecifier().(*RouteAction_HostRewriteHeader); ok {
		return x.HostRewriteHeader
	}
	return ""
}

func (x *RouteAction) GetTimeout() *Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *RouteAction) GetIdleTimeout() *Duration {
	if x != nil {
		return x.IdleTimeout
	}
	return nil
}

func (x *RouteAction) GetRetryPolicyTypedConfig() *Any {
	if x != nil {
		return x.RetryPolicyTypedConfig
	}
	return nil
}

func (x *RouteAction) GetRequestMirrorPolicies() []*RouteAction_RequestMirrorPolicy {
	if x != nil {
		return x.RequestMirrorPolicies
	}
	return nil
}

func (x *RouteAction) GetHashPolicy() []*RouteAction_HashPolicy {
	if x != nil {
		return x.HashPolicy
	}
	return nil
}

func (x *RouteAction) GetUpgradeConfigs() []*RouteAction_UpgradeConfig {
	if x != nil {
		return x.UpgradeConfigs
	}
	return nil
}

func (x *RouteAction) GetMaxStreamDuration() *RouteAction_MaxStreamDuration {
	if x != nil {
		return x.MaxStreamDuration
	}
	return nil
}

type isRouteAction_ClusterSpecifier interface {
	isRouteAction_ClusterSpecifier()
}

type RouteAction_Cluster struct {
	// Indicates the upstream cluster to which the request should be routed
	// to.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3,oneof"`
}

type RouteAction_ClusterHeader struct {
	// Envoy will determine the cluster to route to by reading the value of the
	// HTTP header named by cluster_header from the request headers. If the
	// header is not found or the referenced cluster does not exist, Envoy will
	// return a 404 response.
	//
	// .. attention::
	//
	//   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
	//   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
	//
	// .. note::
	//
	//   If the header appears multiple times only the first value is used.
	ClusterHeader string `protobuf:"bytes,2,opt,name=cluster_header,json=clusterHeader,proto3,oneof"`
}

func (*RouteAction_Cluster) isRouteAction_ClusterSpecifier() {}

func (*RouteAction_ClusterHeader) isRouteAction_ClusterSpecifier() {}

type isRouteAction_HostRewriteSpecifier interface {
	isRouteAction_HostRewriteSpecifier()
}

type RouteAction_HostRewriteLiteral struct {
	// Indicates that during forwarding, the host header will be swapped with
	// this value.
	HostRewriteLiteral string `protobuf:"bytes,6,opt,name=host_rewrite_literal,json=hostRewriteLiteral,proto3,oneof"`
}

type RouteAction_AutoHostRewrite struct {
	// Indicates that during forwarding, the host header will be swapped with
	// the hostname of the upstream host chosen by the cluster manager. This
	// option is applicable only when the destination cluster for a route is of
	// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
	// types has no effect.
	AutoHostRewrite *BoolValue `protobuf:"bytes,7,opt,name=auto_host_rewrite,json=autoHostRewrite,proto3,oneof"`
}

type RouteAction_HostRewriteHeader struct {
	// Indicates that during forwarding, the host header will be swapped with the content of given
	// downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
	// If header value is empty, host header is left intact.
	//
	// .. attention::
	//
	//   Pay attention to the potential security implications of using this option. Provided header
	//   must come from trusted source.
	//
	// .. note::
	//
	//   If the header appears multiple times only the first value is used.
	HostRewriteHeader string `protobuf:"bytes,29,opt,name=host_rewrite_header,json=hostRewriteHeader,proto3,oneof"`
}

func (*RouteAction_HostRewriteLiteral) isRouteAction_HostRewriteSpecifier() {}

func (*RouteAction_AutoHostRewrite) isRouteAction_HostRewriteSpecifier() {}

func (*RouteAction_HostRewriteHeader) isRouteAction_HostRewriteSpecifier() {}

type Rds struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Configuration source specifier for RDS.
	ConfigSource *ConfigSource `protobuf:"bytes,1,opt,name=config_source,json=configSource,proto3" json:"config_source,omitempty"`
	// The name of the route configuration. This name will be passed to the RDS
	// API. This allows an Envoy configuration with multiple HTTP listeners (and
	// associated HTTP connection manager filters) to use different route
	// configurations.
	RouteConfigName string `protobuf:"bytes,2,opt,name=route_config_name,json=routeConfigName,proto3" json:"route_config_name,omitempty"`
}

func (x *Rds) Reset() {
	*x = Rds{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rds) ProtoMessage() {}

func (x *Rds) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rds.ProtoReflect.Descriptor instead.
func (*Rds) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{5}
}

func (x *Rds) GetConfigSource() *ConfigSource {
	if x != nil {
		return x.ConfigSource
	}
	return nil
}

func (x *Rds) GetRouteConfigName() string {
	if x != nil {
		return x.RouteConfigName
	}
	return ""
}

// [#next-free-field: 43]
type HttpConnectionManager struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//    enum CodecType {
	//        // For every new connection, the connection manager will determine which
	//        // codec to use. This mode supports both ALPN for TLS listeners as well as
	//        // protocol inference for plaintext listeners. If ALPN data is available, it
	//        // is preferred, otherwise protocol inference is used. In almost all cases,
	//        // this is the right option to choose for this setting.
	//        AUTO = 0;
	//
	//        // The connection manager will assume that the client is speaking HTTP/1.1.
	//        HTTP1 = 1;
	//
	//        // The connection manager will assume that the client is speaking HTTP/2
	//        // (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
	//        // Prior knowledge is allowed).
	//        HTTP2 = 2;
	//
	//        // [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
	//        // caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
	//        // to distinguish HTTP1 and HTTP2 traffic.
	//        HTTP3 = 3;
	//    }
	//
	//    enum ServerHeaderTransformation {
	//        // Overwrite any Server header with the contents of server_name.
	//        OVERWRITE = 0;
	//
	//        // If no Server header is present, append Server server_name
	//        // If a Server header is present, pass it through.
	//        APPEND_IF_ABSENT = 1;
	//
	//        // Pass through the value of the server header, and do not append a header
	//        // if none is present.
	//        PASS_THROUGH = 2;
	//    }
	//
	//    // How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
	//    // header.
	//    enum ForwardClientCertDetails {
	//        // Do not send the XFCC header to the next hop. This is the default value.
	//        SANITIZE = 0;
	//
	//        // When the client connection is mTLS (Mutual TLS), forward the XFCC header
	//        // in the request.
	//        FORWARD_ONLY = 1;
	//
	//        // When the client connection is mTLS, append the client certificate
	//        // information to the request’s XFCC header and forward it.
	//        APPEND_FORWARD = 2;
	//
	//        // When the client connection is mTLS, reset the XFCC header with the client
	//        // certificate information and send it to the next hop.
	//        SANITIZE_SET = 3;
	//
	//        // Always forward the XFCC header in the request, regardless of whether the
	//        // client connection is mTLS.
	//        ALWAYS_FORWARD_ONLY = 4;
	//    }
	//
	//    // [#next-free-field: 10]
	//    message Tracing {
	//        option (udpa.annotations.versioning).previous_message_type =
	//            "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing";
	//
	//        enum OperationName {
	//            // The HTTP listener is used for ingress/incoming requests.
	//            INGRESS = 0;
	//
	//            // The HTTP listener is used for egress/outgoing requests.
	//            EGRESS = 1;
	//        }
	//
	//        reserved 1, 2;
	//
	//        reserved "operation_name", "request_headers_for_tags";
	//
	//        // Target percentage of requests managed by this HTTP connection manager that will be force
	//        // traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
	//        // header is set. This field is a direct analog for the runtime variable
	//        // 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
	//        // <config_http_conn_man_runtime>`.
	//        // Default: 100%
	//        type.v3.Percent client_sampling = 3;
	//
	//        // Target percentage of requests managed by this HTTP connection manager that will be randomly
	//        // selected for trace generation, if not requested by the client or not forced. This field is
	//        // a direct analog for the runtime variable 'tracing.random_sampling' in the
	//        // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	//        // Default: 100%
	//        type.v3.Percent random_sampling = 4;
	//
	//        // Target percentage of requests managed by this HTTP connection manager that will be traced
	//        // after all other sampling checks have been applied (client-directed, force tracing, random
	//        // sampling). This field functions as an upper limit on the total configured sampling rate. For
	//        // instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
	//        // of client requests with the appropriate headers to be force traced. This field is a direct
	//        // analog for the runtime variable 'tracing.global_enabled' in the
	//        // :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
	//        // Default: 100%
	//        type.v3.Percent overall_sampling = 5;
	//
	//        // Whether to annotate spans with additional data. If true, spans will include logs for stream
	//        // events.
	//        bool verbose = 6;
	//
	//        // Maximum length of the request path to extract and include in the HttpUrl tag. Used to
	//        // truncate lengthy request paths to meet the needs of a tracing backend.
	//        // Default: 256
	//        google.protobuf.UInt32Value max_path_tag_length = 7;
	//
	//        // A list of custom tags with unique tag name to create tags for the active span.
	//        repeated type.tracing.v3.CustomTag custom_tags = 8;
	//
	//        // Configuration for an external tracing provider.
	//        // If not specified, no tracing will be performed.
	//        //
	//        // .. attention::
	//        //   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
	//        //   in Envoy lifetime.
	//        //   Any attempts to reconfigure it or to use different configurations for different HCM filters
	//        //   will be rejected.
	//        //   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
	//        //   on OpenCensus side.
	//        config.trace.v3.Tracing.Http provider = 9;
	//    }
	//
	//    message InternalAddressConfig {
	//        option (udpa.annotations.versioning).previous_message_type =
	//        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager."
	//            "InternalAddressConfig";
	//
	//        // Whether unix socket addresses should be considered internal.
	//        bool unix_sockets = 1;
	//    }
	//
	//    // [#next-free-field: 7]
	//    message SetCurrentClientCertDetails {
	//        option (udpa.annotations.versioning).previous_message_type =
	//        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager."
	//            "SetCurrentClientCertDetails";
	//
	//        reserved 2;
	//
	//        // Whether to forward the subject of the client cert. Defaults to false.
	//        google.protobuf.BoolValue subject = 1;
	//
	//        // Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
	//        // XFCC header comma separated from other values with the value Cert="PEM".
	//        // Defaults to false.
	//        bool cert = 3;
	//
	//        // Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
	//        // format. This will appear in the XFCC header comma separated from other values with the value
	//        // Chain="PEM".
	//        // Defaults to false.
	//        bool chain = 6;
	//
	//        // Whether to forward the DNS type Subject Alternative Names of the client cert.
	//        // Defaults to false.
	//        bool dns = 4;
	//
	//        // Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
	//        // false.
	//        bool uri = 5;
	//    }
	//
	//    // The configuration for HTTP upgrades.
	//    // For each upgrade type desired, an UpgradeConfig must be added.
	//    //
	//    // .. warning::
	//    //
	//    //    The current implementation of upgrade headers does not handle
	//    //    multi-valued upgrade headers. Support for multi-valued headers may be
	//    //    added in the future if needed.
	//    //
	//    // .. warning::
	//    //    The current implementation of upgrade headers does not work with HTTP/2
	//    //    upstreams.
	//    message UpgradeConfig {
	//        option (udpa.annotations.versioning).previous_message_type =
	//        "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager."
	//            "UpgradeConfig";
	//
	//        // The case-insensitive name of this upgrade, e.g. "websocket".
	//        // For each upgrade type present in upgrade_configs, requests with
	//        // Upgrade: [upgrade_type]
	//        // will be proxied upstream.
	//        string upgrade_type = 1;
	//
	//        // If present, this represents the filter chain which will be created for
	//        // this type of upgrade. If no filters are present, the filter chain for
	//        // HTTP connections will be used for this upgrade type.
	//        repeated HttpFilter filters = 2;
	//
	//        // Determines if upgrades are enabled or disabled by default. Defaults to true.
	//        // This can be overridden on a per-route basis with :ref:`cluster
	//        // <envoy_api_field_config.route.v3.RouteAction.upgrade_configs>` as documented in the
	//        // :ref:`upgrade documentation <arch_overview_upgrades>`.
	//        google.protobuf.BoolValue enabled = 3;
	//    }
	//
	//    reserved 27, 11;
	//
	//    reserved "idle_timeout";
	//
	//    // Supplies the type of codec that the connection manager should use.
	//    CodecType codec_type = 1 [(validate.rules).enum = {defined_only: true}];
	//
	//    // The human readable prefix to use when emitting statistics for the
	//    // connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
	//    // more information.
	//    string stat_prefix = 2 [(validate.rules).string = {min_len: 1}];
	//
	//
	// Types that are assignable to RouteSpecifier:
	//	*HttpConnectionManager_Rds
	RouteSpecifier isHttpConnectionManager_RouteSpecifier `protobuf_oneof:"route_specifier"`
}

func (x *HttpConnectionManager) Reset() {
	*x = HttpConnectionManager{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HttpConnectionManager) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpConnectionManager) ProtoMessage() {}

func (x *HttpConnectionManager) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpConnectionManager.ProtoReflect.Descriptor instead.
func (*HttpConnectionManager) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{6}
}

func (m *HttpConnectionManager) GetRouteSpecifier() isHttpConnectionManager_RouteSpecifier {
	if m != nil {
		return m.RouteSpecifier
	}
	return nil
}

func (x *HttpConnectionManager) GetRds() *Rds {
	if x, ok := x.GetRouteSpecifier().(*HttpConnectionManager_Rds); ok {
		return x.Rds
	}
	return nil
}

type isHttpConnectionManager_RouteSpecifier interface {
	isHttpConnectionManager_RouteSpecifier()
}

type HttpConnectionManager_Rds struct {
	// The connection manager’s route table will be dynamically loaded via the RDS API.
	Rds *Rds `protobuf:"bytes,3,opt,name=rds,proto3,oneof"`
}

func (*HttpConnectionManager_Rds) isHttpConnectionManager_RouteSpecifier() {}

type RouteMatch_GrpcRouteMatchOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RouteMatch_GrpcRouteMatchOptions) Reset() {
	*x = RouteMatch_GrpcRouteMatchOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteMatch_GrpcRouteMatchOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteMatch_GrpcRouteMatchOptions) ProtoMessage() {}

func (x *RouteMatch_GrpcRouteMatchOptions) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteMatch_GrpcRouteMatchOptions.ProtoReflect.Descriptor instead.
func (*RouteMatch_GrpcRouteMatchOptions) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{3, 0}
}

type RouteMatch_TlsContextMatchOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If specified, the route will match against whether or not a certificate is presented.
	// If not specified, certificate presentation status (true or false) will not be considered when route matching.
	Presented *BoolValue `protobuf:"bytes,1,opt,name=presented,proto3" json:"presented,omitempty"`
	// If specified, the route will match against whether or not a certificate is validated.
	// If not specified, certificate validation status (true or false) will not be considered when route matching.
	Validated *BoolValue `protobuf:"bytes,2,opt,name=validated,proto3" json:"validated,omitempty"`
}

func (x *RouteMatch_TlsContextMatchOptions) Reset() {
	*x = RouteMatch_TlsContextMatchOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteMatch_TlsContextMatchOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteMatch_TlsContextMatchOptions) ProtoMessage() {}

func (x *RouteMatch_TlsContextMatchOptions) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteMatch_TlsContextMatchOptions.ProtoReflect.Descriptor instead.
func (*RouteMatch_TlsContextMatchOptions) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{3, 1}
}

func (x *RouteMatch_TlsContextMatchOptions) GetPresented() *BoolValue {
	if x != nil {
		return x.Presented
	}
	return nil
}

func (x *RouteMatch_TlsContextMatchOptions) GetValidated() *BoolValue {
	if x != nil {
		return x.Validated
	}
	return nil
}

// An extensible message for matching CONNECT requests.
type RouteMatch_ConnectMatcher struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *RouteMatch_ConnectMatcher) Reset() {
	*x = RouteMatch_ConnectMatcher{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteMatch_ConnectMatcher) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteMatch_ConnectMatcher) ProtoMessage() {}

func (x *RouteMatch_ConnectMatcher) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteMatch_ConnectMatcher.ProtoReflect.Descriptor instead.
func (*RouteMatch_ConnectMatcher) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{3, 2}
}

// The router is capable of shadowing traffic from one cluster to another. The current
// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
// respond before returning the response from the primary cluster. All normal statistics are
// collected for the shadow cluster making this feature useful for testing.
//
// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
//
// .. note::
//
//   Shadowing will not be triggered if the primary cluster does not exist.
type RouteAction_RequestMirrorPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specifies the cluster that requests will be mirrored to. The cluster must
	// exist in the cluster manager configuration.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// Determines if the trace span should be sampled. Defaults to true.
	TraceSampled *BoolValue `protobuf:"bytes,4,opt,name=trace_sampled,json=traceSampled,proto3" json:"trace_sampled,omitempty"`
}

func (x *RouteAction_RequestMirrorPolicy) Reset() {
	*x = RouteAction_RequestMirrorPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_RequestMirrorPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_RequestMirrorPolicy) ProtoMessage() {}

func (x *RouteAction_RequestMirrorPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_RequestMirrorPolicy.ProtoReflect.Descriptor instead.
func (*RouteAction_RequestMirrorPolicy) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 0}
}

func (x *RouteAction_RequestMirrorPolicy) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *RouteAction_RequestMirrorPolicy) GetTraceSampled() *BoolValue {
	if x != nil {
		return x.TraceSampled
	}
	return nil
}

// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
// <arch_overview_load_balancing_types>`.
// [#next-free-field: 7]
type RouteAction_HashPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to PolicySpecifier:
	//	*RouteAction_HashPolicy_Header_
	//	*RouteAction_HashPolicy_Cookie_
	//	*RouteAction_HashPolicy_ConnectionProperties_
	//	*RouteAction_HashPolicy_QueryParameter_
	//	*RouteAction_HashPolicy_FilterState_
	PolicySpecifier isRouteAction_HashPolicy_PolicySpecifier `protobuf_oneof:"policy_specifier"`
	// The flag that short-circuits the hash computing. This field provides a
	// 'fallback' style of configuration: "if a terminal policy doesn't work,
	// fallback to rest of the policy list", it saves time when the terminal
	// policy works.
	//
	// If true, and there is already a hash computed, ignore rest of the
	// list of hash polices.
	// For example, if the following hash methods are configured:
	//
	//  ========= ========
	//  specifier terminal
	//  ========= ========
	//  Header A  true
	//  Header B  false
	//  Header C  false
	//  ========= ========
	//
	// The generateHash process ends if policy "header A" generates a hash, as
	// it's a terminal policy.
	Terminal bool `protobuf:"varint,4,opt,name=terminal,proto3" json:"terminal,omitempty"`
}

func (x *RouteAction_HashPolicy) Reset() {
	*x = RouteAction_HashPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_HashPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_HashPolicy) ProtoMessage() {}

func (x *RouteAction_HashPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_HashPolicy.ProtoReflect.Descriptor instead.
func (*RouteAction_HashPolicy) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1}
}

func (m *RouteAction_HashPolicy) GetPolicySpecifier() isRouteAction_HashPolicy_PolicySpecifier {
	if m != nil {
		return m.PolicySpecifier
	}
	return nil
}

func (x *RouteAction_HashPolicy) GetHeader() *RouteAction_HashPolicy_Header {
	if x, ok := x.GetPolicySpecifier().(*RouteAction_HashPolicy_Header_); ok {
		return x.Header
	}
	return nil
}

func (x *RouteAction_HashPolicy) GetCookie() *RouteAction_HashPolicy_Cookie {
	if x, ok := x.GetPolicySpecifier().(*RouteAction_HashPolicy_Cookie_); ok {
		return x.Cookie
	}
	return nil
}

func (x *RouteAction_HashPolicy) GetConnectionProperties() *RouteAction_HashPolicy_ConnectionProperties {
	if x, ok := x.GetPolicySpecifier().(*RouteAction_HashPolicy_ConnectionProperties_); ok {
		return x.ConnectionProperties
	}
	return nil
}

func (x *RouteAction_HashPolicy) GetQueryParameter() *RouteAction_HashPolicy_QueryParameter {
	if x, ok := x.GetPolicySpecifier().(*RouteAction_HashPolicy_QueryParameter_); ok {
		return x.QueryParameter
	}
	return nil
}

func (x *RouteAction_HashPolicy) GetFilterState() *RouteAction_HashPolicy_FilterState {
	if x, ok := x.GetPolicySpecifier().(*RouteAction_HashPolicy_FilterState_); ok {
		return x.FilterState
	}
	return nil
}

func (x *RouteAction_HashPolicy) GetTerminal() bool {
	if x != nil {
		return x.Terminal
	}
	return false
}

type isRouteAction_HashPolicy_PolicySpecifier interface {
	isRouteAction_HashPolicy_PolicySpecifier()
}

type RouteAction_HashPolicy_Header_ struct {
	// Header hash policy.
	Header *RouteAction_HashPolicy_Header `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}

type RouteAction_HashPolicy_Cookie_ struct {
	// Cookie hash policy.
	Cookie *RouteAction_HashPolicy_Cookie `protobuf:"bytes,2,opt,name=cookie,proto3,oneof"`
}

type RouteAction_HashPolicy_ConnectionProperties_ struct {
	// Connection properties hash policy.
	ConnectionProperties *RouteAction_HashPolicy_ConnectionProperties `protobuf:"bytes,3,opt,name=connection_properties,json=connectionProperties,proto3,oneof"`
}

type RouteAction_HashPolicy_QueryParameter_ struct {
	// Query parameter hash policy.
	QueryParameter *RouteAction_HashPolicy_QueryParameter `protobuf:"bytes,5,opt,name=query_parameter,json=queryParameter,proto3,oneof"`
}

type RouteAction_HashPolicy_FilterState_ struct {
	// Filter state hash policy.
	FilterState *RouteAction_HashPolicy_FilterState `protobuf:"bytes,6,opt,name=filter_state,json=filterState,proto3,oneof"`
}

func (*RouteAction_HashPolicy_Header_) isRouteAction_HashPolicy_PolicySpecifier() {}

func (*RouteAction_HashPolicy_Cookie_) isRouteAction_HashPolicy_PolicySpecifier() {}

func (*RouteAction_HashPolicy_ConnectionProperties_) isRouteAction_HashPolicy_PolicySpecifier() {}

func (*RouteAction_HashPolicy_QueryParameter_) isRouteAction_HashPolicy_PolicySpecifier() {}

func (*RouteAction_HashPolicy_FilterState_) isRouteAction_HashPolicy_PolicySpecifier() {}

// Allows enabling and disabling upgrades on a per-route basis.
// This overrides any enabled/disabled upgrade filter chain specified in the
// HttpConnectionManager
// :ref:`upgrade_configs
// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
// but does not affect any custom filter chain specified there.
type RouteAction_UpgradeConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The case-insensitive name of this upgrade, e.g. "websocket".
	// For each upgrade type present in upgrade_configs, requests with
	// Upgrade: [upgrade_type] will be proxied upstream.
	UpgradeType string `protobuf:"bytes,1,opt,name=upgrade_type,json=upgradeType,proto3" json:"upgrade_type,omitempty"`
	// Determines if upgrades are available on this route. Defaults to true.
	Enabled *BoolValue `protobuf:"bytes,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Configuration for sending data upstream as a raw data payload. This is used for
	// CONNECT requests, when forwarding CONNECT payload as raw TCP.
	// Note that CONNECT support is currently considered alpha in Envoy.
	// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
	ConnectConfig *RouteAction_UpgradeConfig_ConnectConfig `protobuf:"bytes,3,opt,name=connect_config,json=connectConfig,proto3" json:"connect_config,omitempty"`
}

func (x *RouteAction_UpgradeConfig) Reset() {
	*x = RouteAction_UpgradeConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_UpgradeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_UpgradeConfig) ProtoMessage() {}

func (x *RouteAction_UpgradeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_UpgradeConfig.ProtoReflect.Descriptor instead.
func (*RouteAction_UpgradeConfig) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 2}
}

func (x *RouteAction_UpgradeConfig) GetUpgradeType() string {
	if x != nil {
		return x.UpgradeType
	}
	return ""
}

func (x *RouteAction_UpgradeConfig) GetEnabled() *BoolValue {
	if x != nil {
		return x.Enabled
	}
	return nil
}

func (x *RouteAction_UpgradeConfig) GetConnectConfig() *RouteAction_UpgradeConfig_ConnectConfig {
	if x != nil {
		return x.ConnectConfig
	}
	return nil
}

type RouteAction_MaxStreamDuration struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specifies the maximum duration allowed for streams on the route. If not specified, the value
	// from the :ref:`max_stream_duration
	// <envoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` field in
	// :ref:`HttpConnectionManager.common_http_protocol_options
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`
	// is used. If this field is set explicitly to zero, any
	// HttpConnectionManager max_stream_duration timeout will be disabled for
	// this route.
	MaxStreamDuration *Duration `protobuf:"bytes,1,opt,name=max_stream_duration,json=maxStreamDuration,proto3" json:"max_stream_duration,omitempty"`
	// If present, and the request contains a `grpc-timeout header
	// <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
	// *max_stream_duration*, but limit the applied timeout to the maximum value specified here.
	// If set to 0, the `grpc-timeout` header is used without modification.
	GrpcTimeoutHeaderMax *Duration `protobuf:"bytes,2,opt,name=grpc_timeout_header_max,json=grpcTimeoutHeaderMax,proto3" json:"grpc_timeout_header_max,omitempty"`
	// If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by
	// subtracting the provided duration from the header. This is useful for allowing Envoy to set
	// its global timeout to be less than that of the deadline imposed by the calling client, which
	// makes it more likely that Envoy will handle the timeout instead of having the call canceled
	// by the client. If, after applying the offset, the resulting timeout is zero or negative,
	// the stream will timeout immediately.
	GrpcTimeoutHeaderOffset *Duration `protobuf:"bytes,3,opt,name=grpc_timeout_header_offset,json=grpcTimeoutHeaderOffset,proto3" json:"grpc_timeout_header_offset,omitempty"`
}

func (x *RouteAction_MaxStreamDuration) Reset() {
	*x = RouteAction_MaxStreamDuration{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_MaxStreamDuration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_MaxStreamDuration) ProtoMessage() {}

func (x *RouteAction_MaxStreamDuration) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_MaxStreamDuration.ProtoReflect.Descriptor instead.
func (*RouteAction_MaxStreamDuration) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 3}
}

func (x *RouteAction_MaxStreamDuration) GetMaxStreamDuration() *Duration {
	if x != nil {
		return x.MaxStreamDuration
	}
	return nil
}

func (x *RouteAction_MaxStreamDuration) GetGrpcTimeoutHeaderMax() *Duration {
	if x != nil {
		return x.GrpcTimeoutHeaderMax
	}
	return nil
}

func (x *RouteAction_MaxStreamDuration) GetGrpcTimeoutHeaderOffset() *Duration {
	if x != nil {
		return x.GrpcTimeoutHeaderOffset
	}
	return nil
}

type RouteAction_HashPolicy_Header struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the request header that will be used to obtain the hash
	// key. If the request header is not present, no hash will be produced.
	HeaderName string `protobuf:"bytes,1,opt,name=header_name,json=headerName,proto3" json:"header_name,omitempty"`
}

func (x *RouteAction_HashPolicy_Header) Reset() {
	*x = RouteAction_HashPolicy_Header{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_HashPolicy_Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_HashPolicy_Header) ProtoMessage() {}

func (x *RouteAction_HashPolicy_Header) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_HashPolicy_Header.ProtoReflect.Descriptor instead.
func (*RouteAction_HashPolicy_Header) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1, 0}
}

func (x *RouteAction_HashPolicy_Header) GetHeaderName() string {
	if x != nil {
		return x.HeaderName
	}
	return ""
}

// Envoy supports two types of cookie affinity:
//
// 1. Passive. Envoy takes a cookie that's present in the cookies header and
//    hashes on its value.
//
// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
//    on the first request from the client in its response to the client,
//    based on the endpoint the request gets sent to. The client then
//    presents this on the next and all subsequent requests. The hash of
//    this is sufficient to ensure these requests get sent to the same
//    endpoint. The cookie is generated by hashing the source and
//    destination ports and addresses so that multiple independent HTTP2
//    streams on the same connection will independently receive the same
//    cookie, even if they arrive at the Envoy simultaneously.
type RouteAction_HashPolicy_Cookie struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the cookie that will be used to obtain the hash key. If the
	// cookie is not present and ttl below is not set, no hash will be
	// produced.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If specified, a cookie with the TTL will be generated if the cookie is
	// not present. If the TTL is present and zero, the generated cookie will
	// be a session cookie.
	Ttl *Duration `protobuf:"bytes,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// The name of the path for the cookie. If no path is specified here, no path
	// will be set for the cookie.
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
}

func (x *RouteAction_HashPolicy_Cookie) Reset() {
	*x = RouteAction_HashPolicy_Cookie{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_HashPolicy_Cookie) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_HashPolicy_Cookie) ProtoMessage() {}

func (x *RouteAction_HashPolicy_Cookie) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_HashPolicy_Cookie.ProtoReflect.Descriptor instead.
func (*RouteAction_HashPolicy_Cookie) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1, 1}
}

func (x *RouteAction_HashPolicy_Cookie) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RouteAction_HashPolicy_Cookie) GetTtl() *Duration {
	if x != nil {
		return x.Ttl
	}
	return nil
}

func (x *RouteAction_HashPolicy_Cookie) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type RouteAction_HashPolicy_ConnectionProperties struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Hash on source IP address.
	SourceIp bool `protobuf:"varint,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
}

func (x *RouteAction_HashPolicy_ConnectionProperties) Reset() {
	*x = RouteAction_HashPolicy_ConnectionProperties{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_HashPolicy_ConnectionProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_HashPolicy_ConnectionProperties) ProtoMessage() {}

func (x *RouteAction_HashPolicy_ConnectionProperties) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_HashPolicy_ConnectionProperties.ProtoReflect.Descriptor instead.
func (*RouteAction_HashPolicy_ConnectionProperties) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1, 2}
}

func (x *RouteAction_HashPolicy_ConnectionProperties) GetSourceIp() bool {
	if x != nil {
		return x.SourceIp
	}
	return false
}

type RouteAction_HashPolicy_QueryParameter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the URL query parameter that will be used to obtain the hash
	// key. If the parameter is not present, no hash will be produced. Query
	// parameter names are case-sensitive.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *RouteAction_HashPolicy_QueryParameter) Reset() {
	*x = RouteAction_HashPolicy_QueryParameter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_HashPolicy_QueryParameter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_HashPolicy_QueryParameter) ProtoMessage() {}

func (x *RouteAction_HashPolicy_QueryParameter) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_HashPolicy_QueryParameter.ProtoReflect.Descriptor instead.
func (*RouteAction_HashPolicy_QueryParameter) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1, 3}
}

func (x *RouteAction_HashPolicy_QueryParameter) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type RouteAction_HashPolicy_FilterState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of the Object in the per-request filterState, which is an
	// Envoy::Http::Hashable object. If there is no data associated with the key,
	// or the stored object is not Envoy::Http::Hashable, no hash will be produced.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (x *RouteAction_HashPolicy_FilterState) Reset() {
	*x = RouteAction_HashPolicy_FilterState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_HashPolicy_FilterState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_HashPolicy_FilterState) ProtoMessage() {}

func (x *RouteAction_HashPolicy_FilterState) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_HashPolicy_FilterState.ProtoReflect.Descriptor instead.
func (*RouteAction_HashPolicy_FilterState) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 1, 4}
}

func (x *RouteAction_HashPolicy_FilterState) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// Configuration for sending data upstream as a raw data payload. This is used for
// CONNECT or POST requests, when forwarding request payload as raw TCP.
type RouteAction_UpgradeConfig_ConnectConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If set, the route will also allow forwarding POST payload as raw TCP.
	AllowPost bool `protobuf:"varint,2,opt,name=allow_post,json=allowPost,proto3" json:"allow_post,omitempty"`
}

func (x *RouteAction_UpgradeConfig_ConnectConfig) Reset() {
	*x = RouteAction_UpgradeConfig_ConnectConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_xds_rds_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteAction_UpgradeConfig_ConnectConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteAction_UpgradeConfig_ConnectConfig) ProtoMessage() {}

func (x *RouteAction_UpgradeConfig_ConnectConfig) ProtoReflect() protoreflect.Message {
	mi := &file_xds_rds_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteAction_UpgradeConfig_ConnectConfig.ProtoReflect.Descriptor instead.
func (*RouteAction_UpgradeConfig_ConnectConfig) Descriptor() ([]byte, []int) {
	return file_xds_rds_proto_rawDescGZIP(), []int{4, 2, 0}
}

func (x *RouteAction_UpgradeConfig_ConnectConfig) GetAllowPost() bool {
	if x != nil {
		return x.AllowPost
	}
	return false
}

var File_xds_rds_proto protoreflect.FileDescriptor

var file_xds_rds_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x78, 0x64, 0x73, 0x2f, 0x72, 0x64, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x03, 0x78, 0x64, 0x73, 0x1a, 0x0e, 0x78, 0x64, 0x73, 0x2f, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x78, 0x64, 0x73, 0x2f, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x5f,
	0x62, 0x61, 0x73, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb8, 0x03, 0x0a, 0x12, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x35, 0x0a, 0x0d, 0x76, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c,
	0x5f, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x78,
	0x64, 0x73, 0x2e, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x48, 0x6f, 0x73, 0x74, 0x52, 0x0c,
	0x76, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x48, 0x6f, 0x73, 0x74, 0x73, 0x12, 0x32, 0x0a, 0x15,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x68, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x13, 0x69, 0x6e, 0x74,
	0x65, 0x72, 0x6e, 0x61, 0x6c, 0x4f, 0x6e, 0x6c, 0x79, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
	0x12, 0x3b, 0x0a, 0x1a, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x68, 0x65, 0x61,
	0x64, 0x65, 0x72, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x18, 0x05,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x17, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x48, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x73, 0x54, 0x6f, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x39, 0x0a,
	0x19, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
	0x5f, 0x74, 0x6f, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x16, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
	0x54, 0x6f, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x4c, 0x0a, 0x23, 0x6d, 0x6f, 0x73, 0x74,
	0x5f, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
	0x5f, 0x6d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x77, 0x69, 0x6e, 0x73, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1f, 0x6d, 0x6f, 0x73, 0x74, 0x53, 0x70, 0x65, 0x63, 0x69,
	0x66, 0x69, 0x63, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x4d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x57, 0x69, 0x6e, 0x73, 0x12, 0x5d, 0x0a, 0x23, 0x6d, 0x61, 0x78, 0x5f, 0x64, 0x69,
	0x72, 0x65, 0x63, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x62, 0x6f,
	0x64, 0x79, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0b, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x55, 0x49, 0x6e, 0x74, 0x33, 0x32,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x1e, 0x6d, 0x61, 0x78, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x6f, 0x64, 0x79, 0x53, 0x69, 0x7a, 0x65,
	0x42, 0x79, 0x74, 0x65, 0x73, 0x22, 0xe3, 0x03, 0x0a, 0x0b, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61,
	0x6c, 0x48, 0x6f, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x6f, 0x6d,
	0x61, 0x69, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x64, 0x6f, 0x6d, 0x61,
	0x69, 0x6e, 0x73, 0x12, 0x22, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52,
	0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x44, 0x0a, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x69,
	0x72, 0x65, 0x5f, 0x74, 0x6c, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x78,
	0x64, 0x73, 0x2e, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x48, 0x6f, 0x73, 0x74, 0x2e, 0x54,
	0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70,
	0x65, 0x52, 0x0a, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6c, 0x73, 0x12, 0x41, 0x0a,
	0x1d, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x0e,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x48, 0x0a, 0x21, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x61, 0x74, 0x74, 0x65,
	0x6d, 0x70, 0x74, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x13, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1d, 0x69, 0x6e, 0x63,
	0x6c, 0x75, 0x64, 0x65, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74,
	0x49, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x54, 0x0a, 0x1e, 0x70, 0x65,
	0x72, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72,
	0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x12, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x10, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x55, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x52, 0x1a, 0x70, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x42, 0x79, 0x74, 0x65, 0x73,
	0x22, 0x3a, 0x0a, 0x12, 0x54, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65,
	0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x00,
	0x12, 0x11, 0x0a, 0x0d, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x4f, 0x4e, 0x4c,
	0x59, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x4c, 0x4c, 0x10, 0x02, 0x4a, 0x04, 0x08, 0x09,
	0x10, 0x0a, 0x4a, 0x04, 0x08, 0x0c, 0x10, 0x0d, 0x52, 0x11, 0x70, 0x65, 0x72, 0x5f, 0x66, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xbe, 0x04, 0x0a, 0x05,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0e, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x25, 0x0a, 0x05, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x12, 0x28, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x10, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x48, 0x00, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x29, 0x0a, 0x08, 0x6d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78,
	0x64, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x08, 0x6d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x5b, 0x0a, 0x17, 0x74, 0x79, 0x70, 0x65, 0x64, 0x5f, 0x70,
	0x65, 0x72, 0x5f, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x64, 0x50, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x74, 0x65,
	0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x14, 0x74, 0x79,
	0x70, 0x65, 0x64, 0x50, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x12, 0x39, 0x0a, 0x19, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x68, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x18,
	0x0c, 0x20, 0x03, 0x28, 0x09, 0x52, 0x16, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x73, 0x54, 0x6f, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x3b, 0x0a,
	0x1a, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
	0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x18, 0x0b, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x17, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65,
	0x72, 0x73, 0x54, 0x6f, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x54, 0x0a, 0x1e, 0x70, 0x65,
	0x72, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72,
	0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x10, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x10, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x55, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x52, 0x1a, 0x70, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x42, 0x79, 0x74, 0x65, 0x73,
	0x1a, 0x51, 0x0a, 0x19, 0x54, 0x79, 0x70, 0x65, 0x64, 0x50, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
	0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
	0x1e, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x08,
	0x2e, 0x78, 0x64, 0x73, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
	0x02, 0x38, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4a, 0x04, 0x08,
	0x06, 0x10, 0x07, 0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x52, 0x11, 0x70, 0x65, 0x72, 0x5f, 0x66,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x88, 0x04, 0x0a,
	0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x18, 0x0a, 0x06, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x06, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x14, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x49, 0x0a, 0x0f, 0x63,
	0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x18, 0x0c,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x72, 0x12, 0x35, 0x0a, 0x0e, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73,
	0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e,
	0x2e, 0x78, 0x64, 0x73, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0d,
	0x63, 0x61, 0x73, 0x65, 0x53, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x12, 0x39, 0x0a,
	0x04, 0x67, 0x72, 0x70, 0x63, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x78, 0x64,
	0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x47, 0x72, 0x70,
	0x63, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x52, 0x04, 0x67, 0x72, 0x70, 0x63, 0x12, 0x47, 0x0a, 0x0b, 0x74, 0x6c, 0x73, 0x5f,
	0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e,
	0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x54,
	0x6c, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0a, 0x74, 0x6c, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78,
	0x74, 0x1a, 0x17, 0x0a, 0x15, 0x47, 0x72, 0x70, 0x63, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x74, 0x0a, 0x16, 0x54, 0x6c,
	0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x2c, 0x0a, 0x09, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x65,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x42, 0x6f,
	0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x09, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74,
	0x65, 0x64, 0x12, 0x2c, 0x0a, 0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x42, 0x6f, 0x6f, 0x6c,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x1a, 0x10, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x42, 0x10, 0x0a, 0x0e, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x69,
	0x66, 0x69, 0x65, 0x72, 0x4a, 0x04, 0x08, 0x05, 0x10, 0x06, 0x4a, 0x04, 0x08, 0x03, 0x10, 0x04,
	0x52, 0x05, 0x72, 0x65, 0x67, 0x65, 0x78, 0x22, 0xba, 0x13, 0x0a, 0x0b, 0x52, 0x6f, 0x75, 0x74,
	0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x07, 0x63, 0x6c, 0x75, 0x73, 0x74,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x07, 0x63, 0x6c, 0x75, 0x73,
	0x74, 0x65, 0x72, 0x12, 0x27, 0x0a, 0x0e, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x68,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0d, 0x63,
	0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x72, 0x0a, 0x1f,
	0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x6e, 0x6f, 0x74, 0x5f, 0x66, 0x6f, 0x75, 0x6e,
	0x64, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18,
	0x14, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74,
	0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e,
	0x6f, 0x74, 0x46, 0x6f, 0x75, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x43,
	0x6f, 0x64, 0x65, 0x52, 0x1b, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x74, 0x46,
	0x6f, 0x75, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x43, 0x6f, 0x64, 0x65,
	0x12, 0x34, 0x0a, 0x0e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x0d, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78,
	0x5f, 0x72, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d,
	0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x52, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x12, 0x32, 0x0a,
	0x14, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x72, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6c, 0x69,
	0x74, 0x65, 0x72, 0x61, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x48, 0x01, 0x52, 0x12, 0x68,
	0x6f, 0x73, 0x74, 0x52, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61,
	0x6c, 0x12, 0x3c, 0x0a, 0x11, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x72,
	0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x78,
	0x64, 0x73, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x01, 0x52, 0x0f,
	0x61, 0x75, 0x74, 0x6f, 0x48, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x12,
	0x30, 0x0a, 0x13, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x72, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f,
	0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x09, 0x48, 0x01, 0x52, 0x11,
	0x68, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x48, 0x65, 0x61, 0x64, 0x65,
	0x72, 0x12, 0x27, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x30, 0x0a, 0x0c, 0x69, 0x64,
	0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0d, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x0b, 0x69, 0x64, 0x6c, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x43, 0x0a, 0x19,
	0x72, 0x65, 0x74, 0x72, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x74, 0x79, 0x70,
	0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x21, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x08, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x41, 0x6e, 0x79, 0x52, 0x16, 0x72, 0x65, 0x74, 0x72, 0x79,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x54, 0x79, 0x70, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x5c, 0x0a, 0x17, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x72,
	0x72, 0x6f, 0x72, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x18, 0x1e, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x24, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x4d, 0x69, 0x72, 0x72,
	0x6f, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x15, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x4d, 0x69, 0x72, 0x72, 0x6f, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x12,
	0x3c, 0x0a, 0x0b, 0x68, 0x61, 0x73, 0x68, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x0f,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x52, 0x0a, 0x68, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x47, 0x0a,
	0x0f, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x73,
	0x18, 0x19, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x73, 0x12, 0x52, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x74,
	0x72, 0x65, 0x61, 0x6d, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x24, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4d, 0x61, 0x78, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x11, 0x6d, 0x61, 0x78, 0x53, 0x74, 0x72, 0x65,
	0x61, 0x6d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x77, 0x0a, 0x13, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x4d, 0x69, 0x72, 0x72, 0x6f, 0x72, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x07, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x12, 0x33, 0x0a, 0x0d, 0x74,
	0x72, 0x61, 0x63, 0x65, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x63, 0x65, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x64,
	0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x5f,
	0x6b, 0x65, 0x79, 0x1a, 0xc0, 0x05, 0x0a, 0x0a, 0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x12, 0x3c, 0x0a, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x22, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x48, 0x00, 0x52, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
	0x12, 0x3c, 0x0a, 0x06, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x22, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x43, 0x6f,
	0x6f, 0x6b, 0x69, 0x65, 0x48, 0x00, 0x52, 0x06, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x12, 0x67,
	0x0a, 0x15, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x72, 0x6f,
	0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e,
	0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x48,
	0x00, 0x52, 0x14, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,
	0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x55, 0x0a, 0x0f, 0x71, 0x75, 0x65, 0x72, 0x79,
	0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2a, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x48, 0x00, 0x52, 0x0e,
	0x71, 0x75, 0x65, 0x72, 0x79, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x4c,
	0x0a, 0x0c, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x48, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x48, 0x00, 0x52,
	0x0b, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1a, 0x0a, 0x08,
	0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
	0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x1a, 0x29, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64,
	0x65, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x4e,
	0x61, 0x6d, 0x65, 0x1a, 0x51, 0x0a, 0x06, 0x43, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x12, 0x12, 0x0a,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x12, 0x1f, 0x0a, 0x03, 0x74, 0x74, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d,
	0x2e, 0x78, 0x64, 0x73, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x74,
	0x74, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x1a, 0x33, 0x0a, 0x14, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x1b,
	0x0a, 0x09, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x08, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x1a, 0x24, 0x0a, 0x0e, 0x51,
	0x75, 0x65, 0x72, 0x79, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x12, 0x0a,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
	0x65, 0x1a, 0x1f, 0x0a, 0x0b, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65,
	0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
	0x65, 0x79, 0x42, 0x12, 0x0a, 0x10, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x73, 0x70, 0x65,
	0x63, 0x69, 0x66, 0x69, 0x65, 0x72, 0x1a, 0xe1, 0x01, 0x0a, 0x0d, 0x55, 0x70, 0x67, 0x72, 0x61,
	0x64, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x21, 0x0a, 0x0c, 0x75, 0x70, 0x67, 0x72,
	0x61, 0x64, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
	0x75, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x28, 0x0a, 0x07, 0x65,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x78,
	0x64, 0x73, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x07, 0x65, 0x6e,
	0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x53, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
	0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e,
	0x78, 0x64, 0x73, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x43, 0x6f,
	0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x63, 0x6f, 0x6e,
	0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x2e, 0x0a, 0x0d, 0x43, 0x6f,
	0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1d, 0x0a, 0x0a, 0x61,
	0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x70, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x50, 0x6f, 0x73, 0x74, 0x1a, 0xe4, 0x01, 0x0a, 0x11, 0x4d,
	0x61, 0x78, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x3d, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x64,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
	0x78, 0x64, 0x73, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x11, 0x6d, 0x61,
	0x78, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
	0x44, 0x0a, 0x17, 0x67, 0x72, 0x70, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f,
	0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x5f, 0x6d, 0x61, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0d, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x14, 0x67, 0x72, 0x70, 0x63, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x48, 0x65, 0x61, 0x64,
	0x65, 0x72, 0x4d, 0x61, 0x78, 0x12, 0x4a, 0x0a, 0x1a, 0x67, 0x72, 0x70, 0x63, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x5f, 0x6f, 0x66, 0x66,
	0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x78, 0x64, 0x73, 0x2e,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x17, 0x67, 0x72, 0x70, 0x63, 0x54, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x4f, 0x66, 0x66, 0x73, 0x65,
	0x74, 0x22, 0x45, 0x0a, 0x1b, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x74, 0x46,
	0x6f, 0x75, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x43, 0x6f, 0x64, 0x65,
	0x12, 0x17, 0x0a, 0x13, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x55, 0x4e, 0x41, 0x56,
	0x41, 0x49, 0x4c, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09, 0x4e, 0x4f, 0x54,
	0x5f, 0x46, 0x4f, 0x55, 0x4e, 0x44, 0x10, 0x01, 0x22, 0x5a, 0x0a, 0x16, 0x49, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x61, 0x6c, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x1e, 0x50, 0x41, 0x53, 0x53, 0x5f, 0x54, 0x48, 0x52, 0x4f, 0x55,
	0x47, 0x48, 0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x52, 0x45, 0x44, 0x49,
	0x52, 0x45, 0x43, 0x54, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18, 0x48, 0x41, 0x4e, 0x44, 0x4c, 0x45,
	0x5f, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x52, 0x45, 0x44, 0x49, 0x52, 0x45,
	0x43, 0x54, 0x10, 0x01, 0x42, 0x13, 0x0a, 0x11, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x5f,
	0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x72, 0x42, 0x18, 0x0a, 0x16, 0x68, 0x6f, 0x73,
	0x74, 0x5f, 0x72, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
	0x69, 0x65, 0x72, 0x4a, 0x04, 0x08, 0x0c, 0x10, 0x0d, 0x4a, 0x04, 0x08, 0x12, 0x10, 0x13, 0x4a,
	0x04, 0x08, 0x13, 0x10, 0x14, 0x4a, 0x04, 0x08, 0x10, 0x10, 0x11, 0x4a, 0x04, 0x08, 0x16, 0x10,
	0x17, 0x4a, 0x04, 0x08, 0x15, 0x10, 0x16, 0x4a, 0x04, 0x08, 0x0a, 0x10, 0x0b, 0x52, 0x15, 0x72,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x22, 0x69, 0x0a, 0x03, 0x52, 0x64, 0x73, 0x12, 0x36, 0x0a, 0x0d, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x11, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x53,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x53, 0x6f, 0x75,
	0x72, 0x63, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f,
	0x72, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x22,
	0x48, 0x0a, 0x15, 0x48, 0x74, 0x74, 0x70, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x12, 0x1c, 0x0a, 0x03, 0x72, 0x64, 0x73, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x08, 0x2e, 0x78, 0x64, 0x73, 0x2e, 0x52, 0x64, 0x73, 0x48,
	0x00, 0x52, 0x03, 0x72, 0x64, 0x73, 0x42, 0x11, 0x0a, 0x0f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f,
	0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x72, 0x42, 0x2a, 0x5a, 0x25, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x74, 0x69, 0x6e, 0x6d, 0x2f,
	0x68, 0x62, 0x6f, 0x6e, 0x65, 0x2f, 0x65, 0x78, 0x74, 0x2f, 0x75, 0x78, 0x64, 0x73, 0x2f, 0x78,
	0x64, 0x73, 0x88, 0x01, 0x01, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_xds_rds_proto_rawDescOnce sync.Once
	file_xds_rds_proto_rawDescData = file_xds_rds_proto_rawDesc
)

func file_xds_rds_proto_rawDescGZIP() []byte {
	file_xds_rds_proto_rawDescOnce.Do(func() {
		file_xds_rds_proto_rawDescData = protoimpl.X.CompressGZIP(file_xds_rds_proto_rawDescData)
	})
	return file_xds_rds_proto_rawDescData
}

var file_xds_rds_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_xds_rds_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_xds_rds_proto_goTypes = []interface{}{
	(VirtualHost_TlsRequirementType)(0),                 // 0: xds.VirtualHost.TlsRequirementType
	(RouteAction_ClusterNotFoundResponseCode)(0),        // 1: xds.RouteAction.ClusterNotFoundResponseCode
	(RouteAction_InternalRedirectAction)(0),             // 2: xds.RouteAction.InternalRedirectAction
	(*RouteConfiguration)(nil),                          // 3: xds.RouteConfiguration
	(*VirtualHost)(nil),                                 // 4: xds.VirtualHost
	(*Route)(nil),                                       // 5: xds.Route
	(*RouteMatch)(nil),                                  // 6: xds.RouteMatch
	(*RouteAction)(nil),                                 // 7: xds.RouteAction
	(*Rds)(nil),                                         // 8: xds.Rds
	(*HttpConnectionManager)(nil),                       // 9: xds.HttpConnectionManager
	nil,                                                 // 10: xds.Route.TypedPerFilterConfigEntry
	(*RouteMatch_GrpcRouteMatchOptions)(nil),            // 11: xds.RouteMatch.GrpcRouteMatchOptions
	(*RouteMatch_TlsContextMatchOptions)(nil),           // 12: xds.RouteMatch.TlsContextMatchOptions
	(*RouteMatch_ConnectMatcher)(nil),                   // 13: xds.RouteMatch.ConnectMatcher
	(*RouteAction_RequestMirrorPolicy)(nil),             // 14: xds.RouteAction.RequestMirrorPolicy
	(*RouteAction_HashPolicy)(nil),                      // 15: xds.RouteAction.HashPolicy
	(*RouteAction_UpgradeConfig)(nil),                   // 16: xds.RouteAction.UpgradeConfig
	(*RouteAction_MaxStreamDuration)(nil),               // 17: xds.RouteAction.MaxStreamDuration
	(*RouteAction_HashPolicy_Header)(nil),               // 18: xds.RouteAction.HashPolicy.Header
	(*RouteAction_HashPolicy_Cookie)(nil),               // 19: xds.RouteAction.HashPolicy.Cookie
	(*RouteAction_HashPolicy_ConnectionProperties)(nil), // 20: xds.RouteAction.HashPolicy.ConnectionProperties
	(*RouteAction_HashPolicy_QueryParameter)(nil),       // 21: xds.RouteAction.HashPolicy.QueryParameter
	(*RouteAction_HashPolicy_FilterState)(nil),          // 22: xds.RouteAction.HashPolicy.FilterState
	(*RouteAction_UpgradeConfig_ConnectConfig)(nil),     // 23: xds.RouteAction.UpgradeConfig.ConnectConfig
	(*UInt32Value)(nil),                                 // 24: xds.UInt32Value
	(*Metadata)(nil),                                    // 25: xds.Metadata
	(*BoolValue)(nil),                                   // 26: xds.BoolValue
	(*Duration)(nil),                                    // 27: xds.Duration
	(*Any)(nil),                                         // 28: xds.Any
	(*ConfigSource)(nil),                                // 29: xds.ConfigSource
}
var file_xds_rds_proto_depIdxs = []int32{
	4,  // 0: xds.RouteConfiguration.virtual_hosts:type_name -> xds.VirtualHost
	24, // 1: xds.RouteConfiguration.max_direct_response_body_size_bytes:type_name -> xds.UInt32Value
	5,  // 2: xds.VirtualHost.routes:type_name -> xds.Route
	0,  // 3: xds.VirtualHost.require_tls:type_name -> xds.VirtualHost.TlsRequirementType
	24, // 4: xds.VirtualHost.per_request_buffer_limit_bytes:type_name -> xds.UInt32Value
	6,  // 5: xds.Route.match:type_name -> xds.RouteMatch
	7,  // 6: xds.Route.route:type_name -> xds.RouteAction
	25, // 7: xds.Route.metadata:type_name -> xds.Metadata
	10, // 8: xds.Route.typed_per_filter_config:type_name -> xds.Route.TypedPerFilterConfigEntry
	24, // 9: xds.Route.per_request_buffer_limit_bytes:type_name -> xds.UInt32Value
	13, // 10: xds.RouteMatch.connect_matcher:type_name -> xds.RouteMatch.ConnectMatcher
	26, // 11: xds.RouteMatch.case_sensitive:type_name -> xds.BoolValue
	11, // 12: xds.RouteMatch.grpc:type_name -> xds.RouteMatch.GrpcRouteMatchOptions
	12, // 13: xds.RouteMatch.tls_context:type_name -> xds.RouteMatch.TlsContextMatchOptions
	1,  // 14: xds.RouteAction.cluster_not_found_response_code:type_name -> xds.RouteAction.ClusterNotFoundResponseCode
	25, // 15: xds.RouteAction.metadata_match:type_name -> xds.Metadata
	26, // 16: xds.RouteAction.auto_host_rewrite:type_name -> xds.BoolValue
	27, // 17: xds.RouteAction.timeout:type_name -> xds.Duration
	27, // 18: xds.RouteAction.idle_timeout:type_name -> xds.Duration
	28, // 19: xds.RouteAction.retry_policy_typed_config:type_name -> xds.Any
	14, // 20: xds.RouteAction.request_mirror_policies:type_name -> xds.RouteAction.RequestMirrorPolicy
	15, // 21: xds.RouteAction.hash_policy:type_name -> xds.RouteAction.HashPolicy
	16, // 22: xds.RouteAction.upgrade_configs:type_name -> xds.RouteAction.UpgradeConfig
	17, // 23: xds.RouteAction.max_stream_duration:type_name -> xds.RouteAction.MaxStreamDuration
	29, // 24: xds.Rds.config_source:type_name -> xds.ConfigSource
	8,  // 25: xds.HttpConnectionManager.rds:type_name -> xds.Rds
	28, // 26: xds.Route.TypedPerFilterConfigEntry.value:type_name -> xds.Any
	26, // 27: xds.RouteMatch.TlsContextMatchOptions.presented:type_name -> xds.BoolValue
	26, // 28: xds.RouteMatch.TlsContextMatchOptions.validated:type_name -> xds.BoolValue
	26, // 29: xds.RouteAction.RequestMirrorPolicy.trace_sampled:type_name -> xds.BoolValue
	18, // 30: xds.RouteAction.HashPolicy.header:type_name -> xds.RouteAction.HashPolicy.Header
	19, // 31: xds.RouteAction.HashPolicy.cookie:type_name -> xds.RouteAction.HashPolicy.Cookie
	20, // 32: xds.RouteAction.HashPolicy.connection_properties:type_name -> xds.RouteAction.HashPolicy.ConnectionProperties
	21, // 33: xds.RouteAction.HashPolicy.query_parameter:type_name -> xds.RouteAction.HashPolicy.QueryParameter
	22, // 34: xds.RouteAction.HashPolicy.filter_state:type_name -> xds.RouteAction.HashPolicy.FilterState
	26, // 35: xds.RouteAction.UpgradeConfig.enabled:type_name -> xds.BoolValue
	23, // 36: xds.RouteAction.UpgradeConfig.connect_config:type_name -> xds.RouteAction.UpgradeConfig.ConnectConfig
	27, // 37: xds.RouteAction.MaxStreamDuration.max_stream_duration:type_name -> xds.Duration
	27, // 38: xds.RouteAction.MaxStreamDuration.grpc_timeout_header_max:type_name -> xds.Duration
	27, // 39: xds.RouteAction.MaxStreamDuration.grpc_timeout_header_offset:type_name -> xds.Duration
	27, // 40: xds.RouteAction.HashPolicy.Cookie.ttl:type_name -> xds.Duration
	41, // [41:41] is the sub-list for method output_type
	41, // [41:41] is the sub-list for method input_type
	41, // [41:41] is the sub-list for extension type_name
	41, // [41:41] is the sub-list for extension extendee
	0,  // [0:41] is the sub-list for field type_name
}

func init() { file_xds_rds_proto_init() }
func file_xds_rds_proto_init() {
	if File_xds_rds_proto != nil {
		return
	}
	file_xds_base_proto_init()
	file_xds_envoy_base_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_xds_rds_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteConfiguration); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VirtualHost); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Route); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rds); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HttpConnectionManager); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteMatch_GrpcRouteMatchOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteMatch_TlsContextMatchOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteMatch_ConnectMatcher); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_RequestMirrorPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_HashPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_UpgradeConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_MaxStreamDuration); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_HashPolicy_Header); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_HashPolicy_Cookie); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_HashPolicy_ConnectionProperties); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_HashPolicy_QueryParameter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_HashPolicy_FilterState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_xds_rds_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteAction_UpgradeConfig_ConnectConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_xds_rds_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*Route_Route)(nil),
	}
	file_xds_rds_proto_msgTypes[3].OneofWrappers = []interface{}{
		(*RouteMatch_Prefix)(nil),
		(*RouteMatch_Path)(nil),
		(*RouteMatch_ConnectMatcher_)(nil),
	}
	file_xds_rds_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*RouteAction_Cluster)(nil),
		(*RouteAction_ClusterHeader)(nil),
		(*RouteAction_HostRewriteLiteral)(nil),
		(*RouteAction_AutoHostRewrite)(nil),
		(*RouteAction_HostRewriteHeader)(nil),
	}
	file_xds_rds_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*HttpConnectionManager_Rds)(nil),
	}
	file_xds_rds_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*RouteAction_HashPolicy_Header_)(nil),
		(*RouteAction_HashPolicy_Cookie_)(nil),
		(*RouteAction_HashPolicy_ConnectionProperties_)(nil),
		(*RouteAction_HashPolicy_QueryParameter_)(nil),
		(*RouteAction_HashPolicy_FilterState_)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_xds_rds_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_xds_rds_proto_goTypes,
		DependencyIndexes: file_xds_rds_proto_depIdxs,
		EnumInfos:         file_xds_rds_proto_enumTypes,
		MessageInfos:      file_xds_rds_proto_msgTypes,
	}.Build()
	File_xds_rds_proto = out.File
	file_xds_rds_proto_rawDesc = nil
	file_xds_rds_proto_goTypes = nil
	file_xds_rds_proto_depIdxs = nil
}
